#!/bin/env bash

# matrix
# Assignment 1 CS 344
# Author: Gregory D Stula
# Due Date: 2020-01-22


# dims function
#
# desc: gives dimensions row, cols for tab seperated matrix
# input: takes single argument or piped input, which is the name of a file
# 		 if no argument given it reads from stdin with maparray
# output: rows cols
#
# Assumptions: array format is valid
dims() {

    # test that only a singular argument was passed
    # >&2 redirects output to stderr
    if [ $# -gt 1 ]; then
        >&2 echo "Too many arguments"
        exit 1
    fi

    # check if file name is readable or exists
    if [ ! -r $1 ]; then
        >&2 echo "file error"
        exit 1
    fi

    # memory map the file to an array of lines
    # otherwise mapfile defaults to stdin
    if [ $# -eq 0 ]; then
        mapfile dim_matrix
    else
       mapfile dim_matrix < $1
    fi

    # this gives the number of elements in a bash array
    # number of lines is equal to number of rows
    rows=${#dim_matrix[@]}

    # create array from first line in the the file we read
    row_array=(${dim_matrix[0]})

    # count the elements of the first row to get the numer of cols
    cols=${#row_array[@]}

    echo "$rows $cols"

}


# add function
#
# desc: adds two tab seperated matrices
# input: two arguments exactly
# output: prints new matrix with sum
add() {

    # test that two arguments were passed
    # >&2 redirects output to stderr
    if [ $# -ne 2 ]; then
        >&2 echo "Wrong number of arguments"
        exit 1
    fi

    # check if files are readable or exist
    if [ ! -r $1 ] || [ ! -r $2 ]; then
        >&2 echo "file error"
        exit 1
    fi

    # reuse dims function to test dimensions
    dims1=$(dims $1)
    dims2=$(dims $2)

    # Matrix addition requires rows and cols to be exactly the same
    if [ "$dims1" != "$dims2" ]; then
        >&2 echo "Addition not possible."
        exit 1;
    fi

    # mapfile reads the file as an array of lines
    # each line is a row in the tab seperated matrix
    mapfile matrix1 < $1
    mapfile matrix2 < $2

    # iterate over the indeces of the first matrix
    # the ! sign means give us a indeces the @ sign means of the entire array
    # each index refers to a line (aka row)
    for i in "${!matrix1[@]}"; do

        # now operate on each row
        # we create new arrays from the line at the index
        row1=(${matrix1[i]})
        row2=(${matrix2[i]})

        sum_row=()

        # subtract 1 from the size so we can know when a tab is not needed
        eol=$(( ${#row1[@]} - 1 ))

        for j in "${!row1[@]}"; do
            # append new row with the sum of the numbers in each column
            col=$(( ${row1[j]} + ${row2[j]} ))
            sum_row+=$col

            if [ $j -ne $eol ]; then
                sum_row+=$'\t' #matrix is tab seperated
            fi
        done
        # format print each row of the sum matrix
        printf "%s\n" "$sum_row"
    done
}

# transpose function
# desc: transforms a MxN matrix into a NxM matrix
# input: a single argument or if none is provided check stdin
# output: prints a transposed matrix
transpose() {
	# test that no more than a singular argument was passed
    # >&2 redirects output to stderr
    if [ $# -gt 1 ]; then
        >&2 echo "Too many arguments"
        exit 1
    fi

    # Check if file name is readable or exists
    if [ ! -r $1 ]; then
        >&2 echo "file error"
        exit 1
    fi

    # memory map the file to an array of lines if files passed
    # otherwise mapfile defaults to stdin
    if [ $# -eq 0 ]; then
        mapfile transpose_matrix
    else
       mapfile transpose_matrix < $1
    fi

    # turn output of dims function into array with dims and get dimensions
    dim_array=($(printf "%s" "${transpose_matrix[@]}" | dims))

    rows=${dim_array[0]}
    cols=${dim_array[1]}

    # subtract 1 from the size so we can know when a tab is not needed
    eol=$(( rows - 1 ))

    # create a new row from the all the elements in col i
    for ((i=0; i < cols; i++)); do
        new_row=()

        # get and iterate over all ideces j for the array of rows (matrix)
        # the ! is array syntax for expanding the indeces instead of elements
        for j in "${!transpose_matrix[@]}"; do
            line_array=(${transpose_matrix[j]})

            # append new row and add tab if not last element of new row
            new_row+=${line_array[i]}
            if [ $j -ne $eol ]; then
                new_row+=$'\t' #matrix is tab seperated
            fi
        done
        # format print each new transposed row
        printf "%s\n" "$new_row"
    done
}

# multiply function
#
# desc: multiplies an MxN matrix with an NxP matrix to produxe a MxP matrix
# input: exactly two arguments of correctly sized array (as per desc)
# output: a new matrix of MxP size with product

multiply() {

    # Test that two arguments was passed
    # >&2 redirects output to stderr
    # >/dev/null is added to avoid also outputting to stdout
    if [ $# -ne 2 ]; then
        >&2 echo "Wrong number of arguments"
        exit 1
    fi

    # Check if files are readable or exist
    if [ ! -r $1 ] || [ ! -r $2 ]; then
        >&2 echo "file error"
        exit 1
    fi

    # reuse dims function to test dimensions
    # put dimensions in array to easily index them
    dims_array1=($(dims $1))
    dims_array2=($(dims $2))


    rows1=${dims_array1[0]} # M
    cols1=${dims_array1[1]} # N

    rows2=${dims_array2[0]} # N
    cols2=${dims_array2[1]} # P

    # product rol will be MxP so the last tab will be at P-1
    eol=$(( cols2 - 1 ))

    # Check that matrices are MxN and NxP
    # we do this by checking that N = N
    if [ $cols1 -ne $rows2 ]; then
        >&2 echo "Multiplication not possible."
        exit 1;
    fi

    # map the matrix file into array of lines
    mapfile matrix_1 < $1
    mapfile matrix_2 < $2

    # iterate over the number of rows in matrix 1
    for (( i=0; i < rows1; i++ )); do
        product_row=()
        # iterate over the number of cols in matrix 2
        for (( j=0; j < cols2; j++ )); do
            # in this inner loop j is the index of the current column in matrix2
            for (( k=0; k < rows2; k++ )); do
                # get the current row of the first matrix as an array of nums
                line1=(${matrix_1[i]})

                #get the next row of the current colum in the second matrix as an array of nums
                line2=(${matrix_2[k]})

                #multiply the corresponding number in the current line1 row
                # with the number in the current line 2 col
                #accumulate in a sum var
                sum=$(( sum + ${line1[k]} * ${line2[j]} ))
            done
            # reset the sum var to zero to get the next product column value for this product row
            # append the final product of this iteration as a column in the product row
             # tab seperated if not last number in row
            product_row+=$sum
            if [ $j -ne $eol ]; then
                product_row+=$'\t'
            fi
            sum=0
        done
        #format print each row
        printf "%s\n" "$product_row"
    done
}

# mean function
#
# desc: gives a single row that is the average of all the columns
# input: a single argument or read from stdin if no arguments
# output: a line with the numbers
mean() {
    # test that no more than a singular argument was passed
    # >&2 redirects output to stderr
    if [ $# -gt 1 ]; then
        >&2 echo "Too many arguments"
        exit 1
    fi

    # check if file name is readable or exists
    if [ ! -r $1 ]; then
        >&2 echo "file error"
        exit 1
    fi

    # memory map the file to an array of lines if a file name passed
    # otherwise mapfile defaults to stdin
    if [ $# -eq 0 ]; then
        mapfile _matrix
    else
       mapfile _matrix < $1
    fi

    # turn output of dims function into array with dims and set dimensions
    dim_array=($(printf "%s" "${_matrix[@]}" | dims))

    rows=${dim_array[0]}
    cols=${dim_array[1]}



    # use process substitution to pass matrix output to transpose function
    # and get resulting output passed to the mapfile command
    # to get an array of transposed lines for easier column processing
    # note: in the resulting array, each line is a column instead of a row
    mapfile columns < <(printf "%s" "${_matrix[@]}" | transpose)
    mean_line=() #output line

    # swap dimensions after transposing
    tmp=$cols
    cols=$rows
    rows=$tmp

    eol=$(( rows - 1 ))
    # average each line in the columns array
    # the ! is array syntax for expanding the indeces instead of elements
    for i in "${!columns[@]}"; do
        # create array from the line as we did in other function
        col=(${columns[i]})
        mean=0 # initialize/reset accumulator for mean
        for num in "${col[@]}"; do
            mean=$((mean + num)) #accumulate the sum of the column
        done
        # using integer rounded division forumula from assignment directions
        # (a + (b/2)*( (a>0)*2-1 )) / b
        mean=$(( (mean + (cols/2)*( (mean>0)*2-1 )) / cols ))

        # append the output line
        mean_line+=$mean

        # add a tab unless at the end of the line
        if [ $i -ne $eol ]; then
            mean_line+=$'\t'
        fi
    done

    # format print the final output line
    printf "%s\n" "$mean_line"
}


# Call the function named by argument 1, with the remaining arguments passed to it
$1 "${@:2}"

